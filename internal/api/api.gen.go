// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for MessageMetadataMessageType.
const (
	RocketExploded       MessageMetadataMessageType = "RocketExploded"
	RocketLaunched       MessageMetadataMessageType = "RocketLaunched"
	RocketMissionChanged MessageMetadataMessageType = "RocketMissionChanged"
	RocketSpeedDecreased MessageMetadataMessageType = "RocketSpeedDecreased"
	RocketSpeedIncreased MessageMetadataMessageType = "RocketSpeedIncreased"
)

// Defines values for RocketStatus.
const (
	Active   RocketStatus = "active"
	Exploded RocketStatus = "exploded"
)

// Defines values for ListRocketsParamsSortBy.
const (
	Mission ListRocketsParamsSortBy = "mission"
	Speed   ListRocketsParamsSortBy = "speed"
	Status  ListRocketsParamsSortBy = "status"
	Type    ListRocketsParamsSortBy = "type"
)

// Defines values for ListRocketsParamsOrder.
const (
	Asc  ListRocketsParamsOrder = "asc"
	Desc ListRocketsParamsOrder = "desc"
)

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// MessageMetadata defines model for MessageMetadata.
type MessageMetadata struct {
	// Channel Unique channel ID for the rocket
	Channel openapi_types.UUID `json:"channel"`

	// MessageNumber Order of the message within a channel
	MessageNumber int `json:"messageNumber"`

	// MessageTime When the message was sent
	MessageTime time.Time                  `json:"messageTime"`
	MessageType MessageMetadataMessageType `json:"messageType"`
}

// MessageMetadataMessageType defines model for MessageMetadata.MessageType.
type MessageMetadataMessageType string

// Rocket defines model for Rocket.
type Rocket struct {
	// Channel Unique channel ID for the rocket
	Channel openapi_types.UUID `json:"channel"`

	// ExplosionReason Reason for explosion (if status is exploded)
	ExplosionReason *string `json:"explosionReason,omitempty"`

	// LastMessageNumber Last processed message number
	LastMessageNumber *int `json:"lastMessageNumber,omitempty"`

	// LastMessageTime Time of last processed message
	LastMessageTime *time.Time `json:"lastMessageTime,omitempty"`

	// Mission Current mission name
	Mission string `json:"mission"`

	// Speed Current speed of the rocket
	Speed int `json:"speed"`

	// Status Current status of the rocket
	Status RocketStatus `json:"status"`

	// Type Type of rocket
	Type string `json:"type"`
}

// RocketStatus Current status of the rocket
type RocketStatus string

// RocketExplodedPayload defines model for RocketExplodedPayload.
type RocketExplodedPayload struct {
	// Reason Reason for explosion
	Reason string `json:"reason"`
}

// RocketLaunchedPayload defines model for RocketLaunchedPayload.
type RocketLaunchedPayload struct {
	// LaunchSpeed Initial launch speed
	LaunchSpeed int `json:"launchSpeed"`

	// Mission Mission name
	Mission string `json:"mission"`

	// Type Type of rocket
	Type string `json:"type"`
}

// RocketMessage defines model for RocketMessage.
type RocketMessage struct {
	Message  RocketMessage_Message `json:"message"`
	Metadata MessageMetadata       `json:"metadata"`
}

// RocketMessage_Message defines model for RocketMessage.Message.
type RocketMessage_Message struct {
	union json.RawMessage
}

// RocketMissionChangedPayload defines model for RocketMissionChangedPayload.
type RocketMissionChangedPayload struct {
	// NewMission New mission name
	NewMission string `json:"newMission"`
}

// RocketSpeedDecreasedPayload defines model for RocketSpeedDecreasedPayload.
type RocketSpeedDecreasedPayload struct {
	// By Amount by which speed decreased
	By int `json:"by"`
}

// RocketSpeedIncreasedPayload defines model for RocketSpeedIncreasedPayload.
type RocketSpeedIncreasedPayload struct {
	// By Amount by which speed increased
	By int `json:"by"`
}

// ListRocketsParams defines parameters for ListRockets.
type ListRocketsParams struct {
	// SortBy Field to sort by
	SortBy *ListRocketsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Order Sort order
	Order *ListRocketsParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ListRocketsParamsSortBy defines parameters for ListRockets.
type ListRocketsParamsSortBy string

// ListRocketsParamsOrder defines parameters for ListRockets.
type ListRocketsParamsOrder string

// PostMessageJSONRequestBody defines body for PostMessage for application/json ContentType.
type PostMessageJSONRequestBody = RocketMessage

// AsRocketLaunchedPayload returns the union data inside the RocketMessage_Message as a RocketLaunchedPayload
func (t RocketMessage_Message) AsRocketLaunchedPayload() (RocketLaunchedPayload, error) {
	var body RocketLaunchedPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRocketLaunchedPayload overwrites any union data inside the RocketMessage_Message as the provided RocketLaunchedPayload
func (t *RocketMessage_Message) FromRocketLaunchedPayload(v RocketLaunchedPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRocketLaunchedPayload performs a merge with any union data inside the RocketMessage_Message, using the provided RocketLaunchedPayload
func (t *RocketMessage_Message) MergeRocketLaunchedPayload(v RocketLaunchedPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRocketSpeedIncreasedPayload returns the union data inside the RocketMessage_Message as a RocketSpeedIncreasedPayload
func (t RocketMessage_Message) AsRocketSpeedIncreasedPayload() (RocketSpeedIncreasedPayload, error) {
	var body RocketSpeedIncreasedPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRocketSpeedIncreasedPayload overwrites any union data inside the RocketMessage_Message as the provided RocketSpeedIncreasedPayload
func (t *RocketMessage_Message) FromRocketSpeedIncreasedPayload(v RocketSpeedIncreasedPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRocketSpeedIncreasedPayload performs a merge with any union data inside the RocketMessage_Message, using the provided RocketSpeedIncreasedPayload
func (t *RocketMessage_Message) MergeRocketSpeedIncreasedPayload(v RocketSpeedIncreasedPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRocketSpeedDecreasedPayload returns the union data inside the RocketMessage_Message as a RocketSpeedDecreasedPayload
func (t RocketMessage_Message) AsRocketSpeedDecreasedPayload() (RocketSpeedDecreasedPayload, error) {
	var body RocketSpeedDecreasedPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRocketSpeedDecreasedPayload overwrites any union data inside the RocketMessage_Message as the provided RocketSpeedDecreasedPayload
func (t *RocketMessage_Message) FromRocketSpeedDecreasedPayload(v RocketSpeedDecreasedPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRocketSpeedDecreasedPayload performs a merge with any union data inside the RocketMessage_Message, using the provided RocketSpeedDecreasedPayload
func (t *RocketMessage_Message) MergeRocketSpeedDecreasedPayload(v RocketSpeedDecreasedPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRocketExplodedPayload returns the union data inside the RocketMessage_Message as a RocketExplodedPayload
func (t RocketMessage_Message) AsRocketExplodedPayload() (RocketExplodedPayload, error) {
	var body RocketExplodedPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRocketExplodedPayload overwrites any union data inside the RocketMessage_Message as the provided RocketExplodedPayload
func (t *RocketMessage_Message) FromRocketExplodedPayload(v RocketExplodedPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRocketExplodedPayload performs a merge with any union data inside the RocketMessage_Message, using the provided RocketExplodedPayload
func (t *RocketMessage_Message) MergeRocketExplodedPayload(v RocketExplodedPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRocketMissionChangedPayload returns the union data inside the RocketMessage_Message as a RocketMissionChangedPayload
func (t RocketMessage_Message) AsRocketMissionChangedPayload() (RocketMissionChangedPayload, error) {
	var body RocketMissionChangedPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRocketMissionChangedPayload overwrites any union data inside the RocketMessage_Message as the provided RocketMissionChangedPayload
func (t *RocketMessage_Message) FromRocketMissionChangedPayload(v RocketMissionChangedPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRocketMissionChangedPayload performs a merge with any union data inside the RocketMessage_Message, using the provided RocketMissionChangedPayload
func (t *RocketMessage_Message) MergeRocketMissionChangedPayload(v RocketMissionChangedPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RocketMessage_Message) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RocketMessage_Message) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Receive rocket state messages
	// (POST /messages)
	PostMessage(w http.ResponseWriter, r *http.Request)
	// List all rockets
	// (GET /rockets)
	ListRockets(w http.ResponseWriter, r *http.Request, params ListRocketsParams)
	// Get rocket by channel
	// (GET /rockets/{channel})
	GetRocket(w http.ResponseWriter, r *http.Request, channel openapi_types.UUID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Receive rocket state messages
// (POST /messages)
func (_ Unimplemented) PostMessage(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all rockets
// (GET /rockets)
func (_ Unimplemented) ListRockets(w http.ResponseWriter, r *http.Request, params ListRocketsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get rocket by channel
// (GET /rockets/{channel})
func (_ Unimplemented) GetRocket(w http.ResponseWriter, r *http.Request, channel openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostMessage operation middleware
func (siw *ServerInterfaceWrapper) PostMessage(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostMessage(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListRockets operation middleware
func (siw *ServerInterfaceWrapper) ListRockets(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRocketsParams

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", r.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sortBy", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRockets(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRocket operation middleware
func (siw *ServerInterfaceWrapper) GetRocket(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "channel" -------------
	var channel openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "channel", chi.URLParam(r, "channel"), &channel, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channel", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRocket(w, r, channel)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/messages", wrapper.PostMessage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/rockets", wrapper.ListRockets)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/rockets/{channel}", wrapper.GetRocket)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
